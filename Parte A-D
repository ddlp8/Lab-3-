//PARTE A–D – Sistema de contador binario doble con alarma y reset
//Autora: Daniela López


#include <Arduino.h>  // Siempre lo primero que cargo para trabajar con placas tipo ESP32

//
// Pines para LEDs (Manual)
#define ledManual_0 18
#define ledManual_1 21
#define ledManual_2 22
#define ledManual_3 23
// Estos cuatro pines los uso para representar en binario el contador manual

// Pines para LEDs (Automático)
#define ledAuto_0   14
#define ledAuto_1   25
#define ledAuto_2   27
#define ledAuto_3   26
// Lo mismo acá, pero estos representan el contador automático

// LED de Alarma
#define ledAlarma   19  // El LED blanco que se prende/apaga cuando hay coincidencia

// Botones físicos
#define pinSube     15  // Botón para subir el contador manual
#define pinBaja     4   // Botón para bajarlo

// Botón B3: Sensor capacitivo para reset
#define pinReset    5   // El pin donde conecté el sensor capacitivo que resetea el contador automático

//
// Variables globales
volatile uint8_t contadorManual = 0;  // Almacena el valor actual del contador manual (0-15)
volatile uint8_t contadorAuto = 0;    // Almacena el valor del contador automático
volatile bool subio = false;          // Bandera que indica si presionaron el botón de subir
volatile bool bajo = false;           // Bandera que indica si presionaron el de bajar
bool estadoAlarma = false;            // Me dice si el LED blanco está encendido o apagado
bool resetPresionado = false;         // Para detectar un solo flanco de subida del botón de reset

const unsigned long pausa = 200;      // Tiempo mínimo entre pulsos para evitar rebotes
volatile unsigned long tSube = 0;     // Último tiempo en el que se presionó el botón de subir
volatile unsigned long tBaja = 0;     // Último tiempo del botón de bajar

hw_timer_t* tmrAuto = NULL;           // Timer del contador automático

//
// Prototipos
// Estas son funciones que voy a usar más adelante
void apagarLedsManual();
void apagarLedsAuto();
void verBinarioManual(uint8_t valor);
void verBinarioAuto(uint8_t valor);
void IRAM_ATTR ISR_subirManual();
void IRAM_ATTR ISR_bajarManual();
void IRAM_ATTR ISR_contadorAutomatico();

//
void setup() {
  // Configuro cada LED como salida
  pinMode(ledManual_0, OUTPUT);
  pinMode(ledManual_1, OUTPUT);
  pinMode(ledManual_2, OUTPUT);
  pinMode(ledManual_3, OUTPUT);

  pinMode(ledAuto_0, OUTPUT);
  pinMode(ledAuto_1, OUTPUT);
  pinMode(ledAuto_2, OUTPUT);
  pinMode(ledAuto_3, OUTPUT);

  // LED de alarma también como salida
  pinMode(ledAlarma, OUTPUT);
  digitalWrite(ledAlarma, LOW);  // Lo dejo apagado al inicio

  // Configuro los botones físicos con resistencias internas pull-up
  pinMode(pinSube, INPUT_PULLUP);
  pinMode(pinBaja, INPUT_PULLUP);

  // Sensor capacitivo (tiene su propia resistencia pull-down externa)
  pinMode(pinReset, INPUT);

  // Apago todos los LEDs al inicio y muestro los valores iniciales
  apagarLedsManual();
  apagarLedsAuto();
  verBinarioManual(contadorManual);
  verBinarioAuto(contadorAuto);

  delay(100);  // Un pequeño delay para estabilizar el sistema

  // Configuro interrupciones para los botones físicos
  attachInterrupt(digitalPinToInterrupt(pinSube), ISR_subirManual, FALLING);
  attachInterrupt(digitalPinToInterrupt(pinBaja), ISR_bajarManual, FALLING);

  // Configuro el timer automático para que haga su trabajo cada 250 ms
  tmrAuto = timerBegin(0, 80, true); // Prescaler = 80 → 1 tick = 1 µs
  timerAttachInterrupt(tmrAuto, &ISR_contadorAutomatico, true);
  timerAlarmWrite(tmrAuto, 250000, true);  // 250,000 µs = 250 ms
  timerAlarmEnable(tmrAuto);
}

//
void loop() {
  unsigned long ahora = millis();

  // Si se presionó el botón de subir (y pasó el tiempo de rebote)
  if (subio && (ahora - tSube > pausa)) {
    contadorManual = (contadorManual + 1) % 16;
    verBinarioManual(contadorManual);
    subio = false;  // Vuelvo a poner la bandera en false
  }

  // Si se presionó el botón de bajar
  if (bajo && (ahora - tBaja > pausa)) {
    contadorManual = (contadorManual == 0) ? 15 : contadorManual - 1;
    verBinarioManual(contadorManual);
    bajo = false;
  }

  // Si se activó el sensor capacitivo y no lo había detectado antes
  if (digitalRead(pinReset) == HIGH && !resetPresionado) {
    contadorAuto = 0;  // Reinicio el contador automático a cero
    verBinarioAuto(contadorAuto);
    resetPresionado = true;  // Marco que ya lo detecté
  }

  // Espero que se suelte el sensor capacitivo para volver a detectar el siguiente toque
  if (digitalRead(pinReset) == LOW && resetPresionado) {
    resetPresionado = false;
  }
}

//
// Funciones auxiliares

// Apago todos los LEDs del contador manual
void apagarLedsManual() {
  digitalWrite(ledManual_0, LOW);
  digitalWrite(ledManual_1, LOW);
  digitalWrite(ledManual_2, LOW);
  digitalWrite(ledManual_3, LOW);
}

// Apago todos los LEDs del contador automático
void apagarLedsAuto() {
  digitalWrite(ledAuto_0, LOW);
  digitalWrite(ledAuto_1, LOW);
  digitalWrite(ledAuto_2, LOW);
  digitalWrite(ledAuto_3, LOW);
}

// Muestro el número binario en los LEDs manuales
void verBinarioManual(uint8_t n) {
  apagarLedsManual();
  if (n & (1 << 0)) digitalWrite(ledManual_0, HIGH);
  if (n & (1 << 1)) digitalWrite(ledManual_1, HIGH);
  if (n & (1 << 2)) digitalWrite(ledManual_2, HIGH);
  if (n & (1 << 3)) digitalWrite(ledManual_3, HIGH);
}

// Igual pero para los LEDs automáticos
void verBinarioAuto(uint8_t n) {
  apagarLedsAuto();
  if (n & (1 << 0)) digitalWrite(ledAuto_0, HIGH);
  if (n & (1 << 1)) digitalWrite(ledAuto_1, HIGH);
  if (n & (1 << 2)) digitalWrite(ledAuto_2, HIGH);
  if (n & (1 << 3)) digitalWrite(ledAuto_3, HIGH);
}

//
// Interrupciones

// Interrupción para subir el contador manual
void IRAM_ATTR ISR_subirManual() {
  unsigned long t = millis();
  if (t - tSube > pausa) {
    subio = true;
    tSube = t;
  }
}

// Interrupción para bajar el contador manual
void IRAM_ATTR ISR_bajarManual() {
  unsigned long t = millis();
  if (t - tBaja > pausa) {
    bajo = true;
    tBaja = t;
  }
}

// Interrupción del contador automático que se ejecuta cada 250 ms
void IRAM_ATTR ISR_contadorAutomatico() {
  static bool estadoAlarmaInterno = false;       // Alarma interna para alternar el LED
  static uint8_t ultimoValorCoincidente = 255;   // Valor anterior para evitar múltiples cambios seguidos

  contadorAuto = (contadorAuto + 1) % 16;  // Aumento el contador automático
  verBinarioAuto(contadorAuto);            // Actualizo los LEDs

  // Si coinciden ambos contadores
  if (contadorAuto == contadorManual) {
    // Pero solo si es una coincidencia nueva
    if (contadorAuto != ultimoValorCoincidente) {
      estadoAlarmaInterno = !estadoAlarmaInterno;  // Alterno el estado del LED blanco
      digitalWrite(ledAlarma, estadoAlarmaInterno ? HIGH : LOW);
      ultimoValorCoincidente = contadorAuto;  // Guardo el valor actual como referencia
    }
  }
}
