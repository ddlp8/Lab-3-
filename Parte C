//Parte C código correcto

#include <Arduino.h>

//
// Pines para LEDs del contador *manual*
#define ledManual_0 18  // Bit 0
#define ledManual_1 21  // Bit 1
#define ledManual_2 22  // Bit 2
#define ledManual_3 23  // Bit 3

// Pines para LEDs del contador *automático*
#define ledAuto_0   14
#define ledAuto_1   25
#define ledAuto_2   27
#define ledAuto_3   26

// LED de Alarma (se enciende cuando los dos contadores coinciden)
#define ledAlarma   19

// Pines de los botones para controlar el contador manual
#define pinSube     15
#define pinBaja     4

//
// Variables globales
volatile uint8_t contadorManual = 0;  // Contador que controlo con los botones
volatile uint8_t contadorAuto = 0;    // Contador que avanza automáticamente con timer
volatile bool subio = false;          // Bandera para detectar subida manual
volatile bool bajo = false;           // Bandera para detectar bajada manual
bool estadoAlarma = false;            // Estado del LED blanco de alarma (encendido o apagado)
volatile bool coincidenciaDetectada = false; // Bandera que detecta coincidencia

// Variables para antirrebote (evita que un solo toque cuente varias veces)
const unsigned long pausa = 200;
volatile unsigned long tSube = 0;
volatile unsigned long tBaja = 0;

// Timer que controla el contador automático
hw_timer_t* tmrAuto = NULL;

//
// Prototipos de funciones
void apagarLedsManual();
void apagarLedsAuto();
void verBinarioManual(uint8_t valor);
void verBinarioAuto(uint8_t valor);
void IRAM_ATTR ISR_subirManual();
void IRAM_ATTR ISR_bajarManual();
void IRAM_ATTR ISR_contadorAutomatico();

//
void setup() {
  // Configuro los LEDs del contador manual como salidas
  pinMode(ledManual_0, OUTPUT);
  pinMode(ledManual_1, OUTPUT);
  pinMode(ledManual_2, OUTPUT);
  pinMode(ledManual_3, OUTPUT);

  // Configuro los LEDs del contador automático como salidas
  pinMode(ledAuto_0, OUTPUT);
  pinMode(ledAuto_1, OUTPUT);
  pinMode(ledAuto_2, OUTPUT);
  pinMode(ledAuto_3, OUTPUT);

  // LED de alarma como salida y apagado al inicio
  pinMode(ledAlarma, OUTPUT);
  digitalWrite(ledAlarma, LOW);

  // Botones como entradas con resistencia interna pull-up activada
  pinMode(pinSube, INPUT_PULLUP);
  pinMode(pinBaja, INPUT_PULLUP);

  // Estado inicial: todo en cero
  apagarLedsManual();
  apagarLedsAuto();
  verBinarioManual(contadorManual);
  verBinarioAuto(contadorAuto);

  delay(100);  // Pequeña pausa para estabilizar el sistema

  // Configuro las interrupciones para detectar cuando se presionan los botones
  attachInterrupt(digitalPinToInterrupt(pinSube), ISR_subirManual, FALLING);
  attachInterrupt(digitalPinToInterrupt(pinBaja), ISR_bajarManual, FALLING);

  // Configuro el temporizador para que el contador automático suba cada 250 ms
  tmrAuto = timerBegin(0, 80, true); // Prescaler de 80 → 1 tick = 1 µs
  timerAttachInterrupt(tmrAuto, &ISR_contadorAutomatico, true);
  timerAlarmWrite(tmrAuto, 250000, true); // 250000 µs = 250 ms
  timerAlarmEnable(tmrAuto);
}

//
void loop() {
  // Verifico si se presionó el botón de subir
  unsigned long ahora = millis();

  if (subio && (ahora - tSube > pausa)) {
    contadorManual = (contadorManual + 1) % 16; // Cicla entre 0 y 15
    verBinarioManual(contadorManual);           // Actualizo LEDs
    subio = false;
  }

  // Verifico si se presionó el botón de bajar
  if (bajo && (ahora - tBaja > pausa)) {
    contadorManual = (contadorManual == 0) ? 15 : contadorManual - 1;
    verBinarioManual(contadorManual);
    bajo = false;
  }
}

//
// Funciones para manejar los LEDs

void apagarLedsManual() {
  digitalWrite(ledManual_0, LOW);
  digitalWrite(ledManual_1, LOW);
  digitalWrite(ledManual_2, LOW);
  digitalWrite(ledManual_3, LOW);
}

void apagarLedsAuto() {
  digitalWrite(ledAuto_0, LOW);
  digitalWrite(ledAuto_1, LOW);
  digitalWrite(ledAuto_2, LOW);
  digitalWrite(ledAuto_3, LOW);
}

// Enciendo los LEDs correspondientes según el valor del contador manual
void verBinarioManual(uint8_t n) {
  apagarLedsManual();
  if (n & (1 << 0)) digitalWrite(ledManual_0, HIGH);
  if (n & (1 << 1)) digitalWrite(ledManual_1, HIGH);
  if (n & (1 << 2)) digitalWrite(ledManual_2, HIGH);
  if (n & (1 << 3)) digitalWrite(ledManual_3, HIGH);
}

// Enciendo los LEDs correspondientes según el valor del contador automático
void verBinarioAuto(uint8_t n) {
  apagarLedsAuto();
  if (n & (1 << 0)) digitalWrite(ledAuto_0, HIGH);
  if (n & (1 << 1)) digitalWrite(ledAuto_1, HIGH);
  if (n & (1 << 2)) digitalWrite(ledAuto_2, HIGH);
  if (n & (1 << 3)) digitalWrite(ledAuto_3, HIGH);
}

//
// Funciones de interrupción

// Cuando se presiona el botón para subir
void IRAM_ATTR ISR_subirManual() {
  unsigned long t = millis();
  if (t - tSube > pausa) {
    subio = true;
    tSube = t;
  }
}

// Cuando se presiona el botón para bajar
void IRAM_ATTR ISR_bajarManual() {
  unsigned long t = millis();
  if (t - tBaja > pausa) {
    bajo = true;
    tBaja = t;
  }
}

// Interrupción del temporizador: contador automático
void IRAM_ATTR ISR_contadorAutomatico() {
  static bool coincidenciaActiva = false;

  // Aumento el contador automático
  contadorAuto = (contadorAuto + 1) % 16;
  verBinarioAuto(contadorAuto);

  // Si los contadores coinciden y antes no estaban iguales
  if (contadorAuto == contadorManual && !coincidenciaActiva) {
    coincidenciaActiva = true;             // Marco que ya encontré coincidencia
    estadoAlarma = !estadoAlarma;          // Cambio el estado del LED de alarma
    digitalWrite(ledAlarma, estadoAlarma ? HIGH : LOW);
  }

  // Si ya no coinciden, reinicio la bandera para poder detectar la siguiente coincidencia
  if (contadorAuto != contadorManual) {
    coincidenciaActiva = false;
  }
}
